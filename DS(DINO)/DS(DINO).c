#include <stdlib.h>
#include <limits.h>

#include <msp430.h>
#include "data_bins.h"
#include "data_thresholds.h"
#include <nvs.h>
#include <ctpl.h>
#include <ctpl_low_level.h>

extern int ctpl_magic_number;
extern int whichBox;

#define NUM_ITERS 100
#define SAMPLES_PER_ITER 20
#define NUM_BINS 10 /*total number of bins*/
#define SAMPLE_MAX 100 /*max expected value of a sample*/
#undef USE_LEDS
#undef FLASH_ON_BOOT

/*Need to calibrate to get real values for this*/
const unsigned thresholds[NUM_BINS] = {
  10, 20, 30, 40, 50, 60, 70, 80, 90, 0xffff /*last bin is for everything else*/
};

const unsigned quoteOnQuoteRandom[SAMPLES_PER_ITER] = {
   75,  7,   3,   68,  88,  59,  90,  52,  12,  44,  46,  87,  98,  16,  61,  49,  30,  19,  44,  42
};

/* These "pinned" variables are fixed at these addresses. */

/*currTemp is a pointer to the current entry in the data log*/
unsigned int inErrorState;
unsigned int initialized;
unsigned int finished;
unsigned int reboots;
unsigned int numSamples;
unsigned int numSwaps;
nvs_data_handle nvsHandle1;
nvs_data_handle nvsHandle2;
#if defined(__TI_COMPILER_VERSION__)
#pragma PERSISTENT(nvsStorage1)
#elif defined(__IAR_SYSTEMS_ICC__)
__persistent
#endif


uint8_t nvsStorage1[NVS_DATA_STORAGE_SIZE(sizeof(data_t1))] = {0};

#if defined(__TI_COMPILER_VERSION__)
#pragma PERSISTENT(nvsStorage2)
#elif defined(__IAR_SYSTEMS_ICC__)
__persistent
#endif


uint8_t nvsStorage2[NVS_DATA_STORAGE_SIZE(sizeof(data_t2))] = {0};

uint16_t status;
void gpioPinSetup(void);
/*dataLog is a buffer of TEMP_WINDOW NV data entries*/
/*defined in data_array.h, generated by dinoArrayGen.pl... ugh*/
unsigned getOneSample(){

  unsigned ret = quoteOnQuoteRandom[data1.r];
  return ret;

}

void abortWithError(){

  inErrorState = 0xBEEE;

  while(1){
      P1OUT |= BIT0;
      __delay_cycles(300000);
      P1OUT &=~ BIT0;
  }

}

/*We will use __NV_dataBin[] as a list of bins, each of which corresponds
  to a dataerature range.
  We will use __NV_dataThresh[] as a list of thresholds, each of which
  is the upper bound of the data value in the corresponding dataBin bin
  NUM_BINS = 3
  thresholds [ 10 | 20 | 30 ]
  datathresh [  0 |  1 |  2 ]
  databins   [  0 |  0 |  0 ]

  addToBin(15)

  thresholds [ 10 | 20 | 30 ]
  datathresh [  0 |  1 |  2 ]
  databins   [  0 |  1 |  0 ]
  swapBins(0,1)

  thresholds [ 10 | 20 | 30 ]
  datathresh [  1 |  0 |  2 ] <--entry 0 contains "1", a pointer to "20"
  databins   [  1 |  0 |  0 ] <--entry 0 contains "1", the count for "20"
  and so on.
  Invariant: datas that contribute to the value in __NV_dataBin[i]
             were less than __NV_dataBin[i] when they were recorded.

             each entry in thresholds occurs in exactly one location in
             __NV_dataThresh[].
*/
void addToBin(unsigned data){

  /*Fill this out so we pass a value in and get a bin back*/
  unsigned i;
  unsigned thresh = 0xffff;
  for( i = 0; i < NUM_BINS; i++){

    /*Look through the sorted list of histogram thresholds...*/
    if( data < thresholds[i] ){

      /*thresholds[i] is the threshold for this measurment*/
      thresh = thresholds[i];
      break;

    }

  }

  unsigned j;
  /*Find this threshold in the unsorted list of histogram keys*/
  for( j = 0; j < NUM_BINS; j++ ){

    unsigned tInd = __histo_read__NV_dataThresh(j);//the index for this key
    unsigned t = thresholds[tInd];//the key itself

    /*This key (t) matches the threshold
      for this measurement (thresholds[i]).*/
    if( t == thresh ){

      /*Increment the found key's bin's value*/
      unsigned binVal = __histo_read__NV_dataBin(j);
      __histo_write__NV_dataBin(j, binVal+1);

      return;

    }

  }

  /*If we get here, the measurement has no bin in
    the histogram, which is an error*/
  abortWithError();

}

void swapBins(int binI, int binJ){

  if(binI >= NUM_BINS ||
     binJ >= NUM_BINS ){
    return;
  }
  numSwaps++;
  unsigned tmpBinVal = __histo_read__NV_dataBin(binI);
  unsigned tmpThrVal = __histo_read__NV_dataThresh(binI);

  __histo_write__NV_dataThresh(binI, __histo_read__NV_dataThresh(binJ));
  __histo_write__NV_dataBin(binI, __histo_read__NV_dataBin(binJ));
  /*A failure here leaves the data structure corrupted!*/
  __histo_write__NV_dataBin(binJ, tmpBinVal);
  __histo_write__NV_dataThresh(binJ, tmpThrVal);

}

void sortBinsByFrequency(void){

  unsigned i = 0;
  for( i = 1; i < NUM_BINS; i++ ){

    unsigned j = i;
    while( j > 0 && __histo_read__NV_dataBin(j - 1) >
                    __histo_read__NV_dataBin(j) ) {

        swapBins(j,j-1);
        j--;

    }

  }

}


void checkInvariants(void){

  unsigned i;
  unsigned numKeysFound = 0;
  unsigned keysFound[NUM_BINS];
  for( i = 0; i < NUM_BINS; i++ ){
    keysFound[i] = 0;
  }
  for( i = 0; i < NUM_BINS; i++ ){

    unsigned key = __histo_read__NV_dataThresh(i);

    if( keysFound[key] == 0 ){

      keysFound[key] = 1;
      numKeysFound++;

    }else{
      abortWithError();
    }

  }


  if( numKeysFound < NUM_BINS ){
      abortWithError();
  }

}



void initializeNVData() {
  int i;
  if(initialized != 0xBEEE){
    for(i = 0; i < NUM_BINS; i++){
      __histo_write__NV_dataBin(i,0x0);
      /*The bin corresponding to the ith
        threshold is in the ith position to start*/
      __histo_write__NV_dataThresh(i,i);

    }
    reboots = 0;
    numSamples = 0;
    numSwaps = 0;
    initialized = 0xBEEE;
  }
}


int main(void){

  WDTCTL = WDTPW | WDTHOLD;  // Stop watchdog timer
  PM5CTL0 &= ~LOCKLPM5;
  gpioPinSetup();
  P1DIR |= BIT0;
  P1OUT &=~ BIT0;
  P1DIR |= BIT1;
  P1OUT &=~ BIT1;
  nvsHandle1 = nvs_data_init(nvsStorage1, sizeof(data_t1));
  status = nvs_data_restore(nvsHandle1, &data1, ctpl_magic_number,whichBox);
  nvsHandle2 = nvs_data_init(nvsStorage2, sizeof(data_t2));
  status = nvs_data_restore(nvsHandle2, &data2,ctpl_magic_number,whichBox);
  ctpl_init();

  if( inErrorState == 0xBEEE ){

    abortWithError();

  }

  initializeNVData();


  while( data1.numSamples < (NUM_ITERS * SAMPLES_PER_ITER) ){

    data1.r = 0;
    while(data1.r < SAMPLES_PER_ITER){
      unsigned samp = getOneSample();

      addToBin(samp);

      data1.numSamples = data1.numSamples + 1;
      data1.r = data1.r + 1;

      status = nvs_data_commit(nvsHandle1, &data1,whichBox);
      status = nvs_data_commit(nvsHandle2, &data2,whichBox);
      ctpl_saveCpuStackEnterLpm(CTPL_MODE_NONE,0);
      P4OUT |= BIT3;
         P4OUT &=~ BIT3;
    }

    status = nvs_data_commit(nvsHandle1, &data1,whichBox);
    status = nvs_data_commit(nvsHandle2, &data2,whichBox);
    ctpl_saveCpuStackEnterLpm(CTPL_MODE_NONE,0);
    P4OUT |= BIT3;
       P4OUT &=~ BIT3;
    sortBinsByFrequency();

    status = nvs_data_commit(nvsHandle1, &data1,whichBox);
    status = nvs_data_commit(nvsHandle2, &data2,whichBox);
    ctpl_saveCpuStackEnterLpm(CTPL_MODE_NONE,0);
    P4OUT |= BIT3;
    P4OUT &=~ BIT3;
    checkInvariants();

  }


  finished = 0xBEEE;
  P2OUT |= BIT6;
  P2OUT &=~ BIT6;
  if (data2.__NV_dataThresh7 == 9 && data1.__NV_dataBin9 == 500) {
  P1OUT |= BIT0;
  }
  while( 1 ){


  }

}
void gpioPinSetup () {
    P4OUT &=~ BIT3;
    P4SEL0 &=~ (BIT3);
    P4SEL1 &=~ (BIT3);
    P4REN &=~ BIT3;
    P4DIR |= BIT3;

    P2OUT |= BIT5;
    P2SEL0 &=~ (BIT5);
    P2REN |= BIT5;
    P2DIR |= BIT5;
    P2OUT &=~ BIT5;

    P2OUT &=~ BIT6;
    P2SEL0 &=~ (BIT6);
    P2REN |= BIT6;
    P2DIR |= BIT6;


}
